================================================================================
IMPLEMENTATION PLAN: AUTH CHECK CALLBACK FEATURE
================================================================================

Feature: Add optional `check` callback parameter to auth functions
Issue: #9 (Inspired by scoped permissions request)
Status: COMPLETED
Priority: Medium

================================================================================
EXECUTIVE SUMMARY
================================================================================

Add an OPTIONAL `check` parameter to existing auth functions that allows
users to provide custom authorization logic that runs AFTER authentication.
This enables dynamic permission checking based on request context without
imposing any conventions on permission naming.

Key Design Decisions:
1. Add to EXISTING functions (not new functions) - keeps API clean
2. OPTIONAL parameter - doesn't affect existing users
3. Single callback OR list of callbacks with mode parameter
4. Consistent across all integration patterns (FastAPI deps, decorators, Flask)

================================================================================
SECTION 1: TYPE DEFINITIONS
================================================================================

Add to core.py:

```python
from typing import Callable, Union, Sequence

# Type for authorization check callback
# FastAPI: receives (user, request), returns bool
# Flask: receives (user,), returns bool (request is global via flask.request)

AuthCheck = Callable[[AuthenticatedUser, Any], bool]  # FastAPI (Any = Request)
AuthCheckSync = Callable[[AuthenticatedUser], bool]   # Flask

# For async support in FastAPI
AuthCheckAsync = Callable[[AuthenticatedUser, Any], Awaitable[bool]]

# Union type for flexibility
AuthCheckCallable = Union[AuthCheck, AuthCheckAsync]
```

================================================================================
SECTION 2: FASTAPI DEPENDENCIES (dependencies.py)
================================================================================

2.1 Update require_auth()
-------------------------

Before:
```python
def require_auth(
    guard: AuthGuard,
    *,
    allow_api_key: bool = True,
) -> Callable[..., Any]:
```

After:
```python
def require_auth(
    guard: AuthGuard,
    *,
    allow_api_key: bool = True,
    check: AuthCheckCallable | None = None,
    checks: Sequence[AuthCheckCallable] | None = None,
    check_mode: Literal["all", "any"] = "all",
    check_error: str = "Authorization check failed",
) -> Callable[..., Any]:
    """
    Create dependency that requires authentication.

    Args:
        guard: AuthGuard instance
        allow_api_key: Whether to accept API key authentication
        check: Single authorization check callback (optional)
        checks: List of authorization check callbacks (optional)
        check_mode: "all" requires all checks pass, "any" requires one
        check_error: Error message when check fails

    The check callback signature:
        def my_check(user: AuthenticatedUser, request: Request) -> bool:
            # Return True to allow, False to deny
            ...

    Examples:
        # Simple auth only
        require_auth(auth)

        # With single check
        require_auth(auth, check=can_access_domain)

        # With multiple checks (all must pass)
        require_auth(auth, checks=[is_active, has_subscription])

        # With multiple checks (any can pass)
        require_auth(auth, checks=[is_admin, is_owner], check_mode="any")
    """
    async def dependency(
        request: Request,  # Now always required for checks
        authorization: AuthorizationHeader = None,
        x_api_key: ApiKeyHeader = None,
    ) -> AuthenticatedUser:
        api_key = x_api_key if allow_api_key else None
        user = await guard.authenticate_or_raise(authorization, api_key)

        # Run authorization checks if provided
        await _run_auth_checks(
            user, request, check, checks, check_mode, check_error
        )

        return user

    return dependency
```

2.2 Add Helper Function
-----------------------

```python
async def _run_auth_checks(
    user: AuthenticatedUser,
    request: Request,
    check: AuthCheckCallable | None,
    checks: Sequence[AuthCheckCallable] | None,
    check_mode: Literal["all", "any"],
    check_error: str,
) -> None:
    """Run authorization checks and raise on failure."""
    all_checks: list[AuthCheckCallable] = []

    if check is not None:
        all_checks.append(check)
    if checks is not None:
        all_checks.extend(checks)

    if not all_checks:
        return  # No checks to run

    results: list[bool] = []
    for check_fn in all_checks:
        # Support both sync and async checks
        if asyncio.iscoroutinefunction(check_fn):
            result = await check_fn(user, request)
        else:
            result = check_fn(user, request)
        results.append(result)

        # Short-circuit for "any" mode on success
        if check_mode == "any" and result:
            return

        # Short-circuit for "all" mode on failure
        if check_mode == "all" and not result:
            raise PermissionDeniedError(check_error)

    # Final check
    if check_mode == "all" and not all(results):
        raise PermissionDeniedError(check_error)
    if check_mode == "any" and not any(results):
        raise PermissionDeniedError(check_error)
```

2.3 Update Other Dependencies
-----------------------------

Apply same pattern to:
- require_permission()
- require_any_permission()
- require_all_permissions()
- require_permission_pattern()
- require_role()
- require_any_role()
- optional_auth()

For permission functions, check runs AFTER permission check:
```python
def require_permission(
    guard: AuthGuard,
    permission: str,
    *,
    allow_api_key: bool = True,
    check: AuthCheckCallable | None = None,  # NEW
    checks: Sequence[AuthCheckCallable] | None = None,  # NEW
    check_mode: Literal["all", "any"] = "all",  # NEW
    check_error: str = "Authorization check failed",  # NEW
) -> Callable[..., Any]:
```

================================================================================
SECTION 3: FASTAPI DECORATORS (decorators.py)
================================================================================

3.1 Update @protected Decorator
-------------------------------

```python
def protected(
    guard: AuthGuard,
    *,
    allow_api_key: bool = True,
    check: Callable[[AuthenticatedUser, Request], bool] | None = None,
    checks: Sequence[Callable[[AuthenticatedUser, Request], bool]] | None = None,
    check_mode: Literal["all", "any"] = "all",
    check_error: str = "Authorization check failed",
) -> Callable[[Callable[P, T]], Callable[P, T]]:
    """
    Decorator to protect a route with authentication.

    Example:
        def can_edit_resource(user: AuthenticatedUser, request: Request) -> bool:
            resource_id = request.path_params.get("id")
            return user.has_permission(f"resource:{resource_id}:edit")

        @app.put("/resources/{id}")
        @protected(auth, check=can_edit_resource)
        async def update_resource(request: Request, auth_user: AuthenticatedUser):
            ...
    """
```

3.2 Update Other Decorators
---------------------------

Apply same pattern to:
- @permission_required()
- @permissions_required()
- @role_required()
- @permission_pattern_required()

================================================================================
SECTION 4: FLASK DECORATORS (flask.py)
================================================================================

4.1 Flask Check Signature
-------------------------

Flask uses global `flask.request`, so check signature is simpler:

```python
FlaskAuthCheck = Callable[[AuthenticatedUser], bool]
```

But we can also provide request if user wants:
```python
from flask import request as flask_request

def my_check(user: AuthenticatedUser) -> bool:
    domain = flask_request.view_args.get("domain", "")
    scope = domain.split('.')[0]
    return user.has_any_permission(...)
```

4.2 Update @login_required
--------------------------

```python
def login_required(
    check: Callable[[AuthenticatedUser], bool] | None = None,
    checks: Sequence[Callable[[AuthenticatedUser], bool]] | None = None,
    check_mode: Literal["all", "any"] = "all",
    check_error: str = "Authorization check failed",
) -> Callable[[Callable[P, T]], Callable[P, T]]:
    """
    Decorator to require authentication with optional checks.

    Example:
        def can_access_tenant(user: AuthenticatedUser) -> bool:
            tenant_id = request.view_args.get("tenant_id")
            return user.org_id == tenant_id

        @app.route("/tenants/<tenant_id>/data")
        @login_required(check=can_access_tenant)
        def get_tenant_data(tenant_id):
            ...
    """
```

Note: If no check provided, behaves exactly as before.

4.3 Update @permission_required
-------------------------------

```python
def permission_required(
    permission: str,
    check: Callable[[AuthenticatedUser], bool] | None = None,
    checks: Sequence[Callable[[AuthenticatedUser], bool]] | None = None,
    check_mode: Literal["all", "any"] = "all",
    check_error: str = "Authorization check failed",
) -> Callable[[Callable[P, T]], Callable[P, T]]:
```

================================================================================
SECTION 5: MIDDLEWARE (middleware.py)
================================================================================

5.1 Optional: Add on_authorize Callback
---------------------------------------

For middleware, add optional authorization callback:

```python
class AuthMiddleware(BaseHTTPMiddleware):
    def __init__(
        self,
        app: ASGIApp,
        guard: AuthGuard,
        *,
        exclude_paths: set[str] | None = None,
        require_auth_paths: set[str] | None = None,
        on_error: Callable[[Request, AuthError], Response] | None = None,
        on_authorize: Callable[[AuthenticatedUser, Request], bool] | None = None,  # NEW
    ):
```

This runs for ALL requests through middleware. For route-specific checks,
use dependencies or decorators instead.

================================================================================
SECTION 6: USAGE EXAMPLES
================================================================================

6.1 Issue #9 Use Case (Scoped Permissions)
------------------------------------------

```python
# Define check function (user's custom logic, their conventions)
def can_access_domain(user: AuthenticatedUser, request: Request) -> bool:
    domain = request.path_params.get("domain", "")
    scope = domain.split('.')[0]
    return user.has_any_permission(
        f"controller.write.services_{scope}",
        "controller.write.services_all",
        "controller.admin",
    )

# Use with dependency
@router.post("/{domain}/services")
async def register_service(
    domain: str,
    user: AuthenticatedUser = Depends(require_auth(auth, check=can_access_domain)),
):
    # Already authorized for this domain!
    ...

# Or reusable across routes
domain_access = require_auth(auth, check=can_access_domain)

@router.post("/{domain}/services")
async def register_service(domain: str, user = Depends(domain_access)):
    ...

@router.delete("/{domain}/services/{id}")
async def delete_service(domain: str, id: str, user = Depends(domain_access)):
    ...
```

6.2 Multi-Tenant Check
----------------------

```python
def belongs_to_tenant(user: AuthenticatedUser, request: Request) -> bool:
    tenant_id = request.path_params.get("tenant_id")
    return user.org_id == tenant_id or user.has_permission("admin:cross_tenant")

@router.get("/tenants/{tenant_id}/users")
async def list_users(
    tenant_id: str,
    user = Depends(require_auth(auth, check=belongs_to_tenant)),
):
    ...
```

6.3 Resource Ownership Check
----------------------------

```python
async def owns_resource(user: AuthenticatedUser, request: Request) -> bool:
    resource_id = request.path_params.get("id")
    # Could even do async DB lookup
    resource = await get_resource(resource_id)
    return resource.owner_id == user.user_id or user.has_permission("admin:access")

@router.put("/resources/{id}")
async def update_resource(
    id: str,
    user = Depends(require_auth(auth, check=owns_resource)),
):
    ...
```

6.4 Multiple Checks (All Must Pass)
-----------------------------------

```python
def is_verified(user: AuthenticatedUser, request: Request) -> bool:
    return user.metadata.get("email_verified", False)

def has_payment(user: AuthenticatedUser, request: Request) -> bool:
    return user.metadata.get("subscription_active", False)

@router.post("/premium/features")
async def premium_feature(
    user = Depends(require_auth(
        auth,
        checks=[is_verified, has_payment],
        check_mode="all",  # Both must pass
        check_error="Premium subscription required",
    )),
):
    ...
```

6.5 Multiple Checks (Any Can Pass)
----------------------------------

```python
def is_owner(user: AuthenticatedUser, request: Request) -> bool:
    resource_id = request.path_params.get("id")
    return check_ownership(user.user_id, resource_id)

def is_admin(user: AuthenticatedUser, request: Request) -> bool:
    return user.has_permission("admin:access")

@router.delete("/resources/{id}")
async def delete_resource(
    id: str,
    user = Depends(require_auth(
        auth,
        checks=[is_owner, is_admin],
        check_mode="any",  # Owner OR admin can delete
    )),
):
    ...
```

6.6 Flask Example
-----------------

```python
from flask import request
from ab0t_auth.flask import login_required

def can_access_domain(user: AuthenticatedUser) -> bool:
    domain = request.view_args.get("domain", "")
    scope = domain.split('.')[0]
    return user.has_any_permission(
        f"controller.write.services_{scope}",
        "controller.write.services_all",
        "controller.admin",
    )

@app.route("/<domain>/services", methods=["POST"])
@login_required(check=can_access_domain)
def register_service(domain):
    ...
```

================================================================================
SECTION 7: IMPLEMENTATION TASKS
================================================================================

Phase 1: Core Types and Helpers
-------------------------------
[x] Add AuthCheck type aliases to core.py
[x] Add _run_auth_checks helper to dependencies.py
[x] Add _run_auth_checks_sync helper to flask.py
[x] Write unit tests for check helpers

Phase 2: FastAPI Dependencies
-----------------------------
[x] Update require_auth() with check params
[x] Update require_permission() with check params
[x] Update require_any_permission() with check params
[x] Update require_all_permissions() with check params
[x] Update require_permission_pattern() with check params
[x] Update require_role() with check params
[x] Update require_any_role() with check params
[x] Update optional_auth() with check params
[x] Write tests for each updated dependency

Phase 3: FastAPI Decorators
---------------------------
[x] Update @protected() with check params
[x] Update @permission_required() with check params
[x] Update @permissions_required() with check params
[x] Update @role_required() with check params
[x] Update @permission_pattern_required() with check params
[x] Write tests for each updated decorator

Phase 4: Flask Decorators
-------------------------
[x] Update @login_required() with check params
[x] Update @permission_required() with check params
[x] Update @permissions_required() with check params
[x] Update @role_required() with check params
[x] Update @permission_pattern_required() with check params
[x] Write tests for Flask decorators

Phase 5: Documentation
----------------------
[x] Update README with check callback examples
[x] Update docstrings with examples
[x] Add cookbook section for common patterns
[x] Update system prompt artifact

Phase 6: Response to Issue #9
-----------------------------
[ ] Comment on issue with solution
[ ] Close issue as resolved (can be done with existing + new check feature)

================================================================================
SECTION 8: BACKWARDS COMPATIBILITY
================================================================================

This feature is 100% backwards compatible:

1. All new parameters are OPTIONAL with default None
2. Existing code works unchanged
3. Request parameter added to dependency signature is handled by FastAPI
4. No breaking changes to any public API

================================================================================
SECTION 9: TESTING STRATEGY
================================================================================

Test Categories:
1. No check (existing behavior preserved)
2. Single check - passes
3. Single check - fails
4. Multiple checks, mode="all", all pass
5. Multiple checks, mode="all", one fails
6. Multiple checks, mode="any", one passes
7. Multiple checks, mode="any", all fail
8. Async check functions
9. Check with request.path_params access
10. Check with request.query_params access
11. Check with request.headers access
12. Custom error messages
13. Integration with permission checks
14. Flask request.view_args access

================================================================================
SECTION 10: ALTERNATIVE DESIGNS CONSIDERED
================================================================================

1. New function names (require_auth_with_check)
   - Rejected: API bloat, harder to discover
   - Chosen: Add params to existing functions

2. Class-based checker objects
   - Rejected: Over-engineering, Pythonic is functions
   - Chosen: Simple callable (function or lambda)

3. Check as first positional arg
   - Rejected: Breaking change, confusing
   - Chosen: Keyword-only parameter

4. Separate check_all() and check_any() functions
   - Rejected: API bloat
   - Chosen: Single checks param with mode

================================================================================
END OF IMPLEMENTATION PLAN
================================================================================
