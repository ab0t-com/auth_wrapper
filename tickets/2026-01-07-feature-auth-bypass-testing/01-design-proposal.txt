Design Proposal: Global Auth Bypass for Testing
================================================

Date: 2026-01-07
Author: Claude Code Assistant
GitHub Issue: #4

Problem Statement
-----------------
Developers need to test application logic without setting up full authentication
infrastructure. Current options require either:
- Running a local auth server
- Generating valid JWT tokens
- Mocking at the test level

A global bypass would simplify local development and testing.

Alternatives Considered
-----------------------

1. AUTH_ENABLED=false (Simple disable)
   - Pros: Simple, one variable
   - Cons: Too easy to accidentally enable in production
   - Cons: Skips auth entirely, breaks code expecting user context
   - REJECTED: Too risky

2. Test fixtures only (No runtime bypass)
   - Pros: No production risk
   - Cons: Doesn't help with local development
   - Cons: Every test needs explicit mocking
   - REJECTED: Doesn't solve the use case

3. Defense-in-depth bypass with injected user (SELECTED)
   - Pros: Requires two env vars (hard to accidentally enable)
   - Pros: Injects real user object (maintains code paths)
   - Pros: Logs WARNING on every request (obvious when active)
   - Pros: Configurable test user (flexible testing)
   - Cons: More complex than simple disable
   - SELECTED: Best balance of safety and utility

Selected Approach: Defense-in-Depth Bypass
------------------------------------------

Environment Variables:
  AB0T_AUTH_BYPASS=true       # Primary bypass flag
  AB0T_AUTH_DEBUG=true        # Secondary gate (both required)

  # Optional configuration:
  AB0T_AUTH_BYPASS_USER_ID=test_user
  AB0T_AUTH_BYPASS_EMAIL=test@local
  AB0T_AUTH_BYPASS_PERMISSIONS=users:read,users:write
  AB0T_AUTH_BYPASS_ROLES=admin,user
  AB0T_AUTH_BYPASS_ORG_ID=test_org

Safety Features:
  1. Two variables required - single misconfiguration won't enable
  2. WARNING logged every request - visible in all log aggregators
  3. Real user injected - permissions still enforced
  4. New AuthMethod.BYPASS - clearly identified in metrics/logs

Implementation Location
-----------------------

Files to modify:
  1. src/ab0t_auth/core.py
     - Add AuthMethod.BYPASS enum value
     - Add TokenType.NONE enum value (if not exists)

  2. src/ab0t_auth/config.py
     - Add bypass configuration loading from env vars
     - Add BypassConfig dataclass

  3. src/ab0t_auth/guard.py
     - Add _check_auth_bypass() method
     - Call at start of authenticate() method
     - Log WARNING when bypass active

  4. src/ab0t_auth/middleware.py
     - Integrate bypass check in request handling

  5. tests/test_bypass.py
     - Test bypass activation requires both env vars
     - Test bypass injects correct user
     - Test bypass logs WARNING
     - Test bypass respects configuration

Code Design
-----------

```python
# config.py
@dataclass(frozen=True)
class BypassConfig:
    """Configuration for auth bypass (testing only)."""
    enabled: bool = False
    user_id: str = "bypass_user"
    email: str = "bypass@test.local"
    permissions: tuple[str, ...] = ()
    roles: tuple[str, ...] = ()
    org_id: str | None = None

def load_bypass_config() -> BypassConfig:
    """Load bypass config from environment variables."""
    bypass = os.getenv("AB0T_AUTH_BYPASS", "").lower() == "true"
    debug = os.getenv("AB0T_AUTH_DEBUG", "").lower() == "true"

    if not (bypass and debug):
        return BypassConfig(enabled=False)

    return BypassConfig(
        enabled=True,
        user_id=os.getenv("AB0T_AUTH_BYPASS_USER_ID", "bypass_user"),
        email=os.getenv("AB0T_AUTH_BYPASS_EMAIL", "bypass@test.local"),
        permissions=tuple(filter(None, os.getenv("AB0T_AUTH_BYPASS_PERMISSIONS", "").split(","))),
        roles=tuple(filter(None, os.getenv("AB0T_AUTH_BYPASS_ROLES", "").split(","))),
        org_id=os.getenv("AB0T_AUTH_BYPASS_ORG_ID"),
    )
```

```python
# guard.py
def _check_auth_bypass(self) -> AuthResult | None:
    """Check if auth bypass is enabled and return bypass user."""
    if not self._bypass_config.enabled:
        return None

    self._logger.warning(
        "AUTH BYPASS ACTIVE",
        event_type="auth_bypass",
        user_id=self._bypass_config.user_id,
        warning="Not for production use",
    )

    user = AuthenticatedUser(
        user_id=self._bypass_config.user_id,
        email=self._bypass_config.email,
        org_id=self._bypass_config.org_id,
        permissions=self._bypass_config.permissions,
        roles=self._bypass_config.roles,
        auth_method=AuthMethod.BYPASS,
        token_type=TokenType.NONE,
    )

    return AuthResult.ok(user)
```

Usage Examples
--------------

# Local development
AB0T_AUTH_DEBUG=true AB0T_AUTH_BYPASS=true uvicorn app:app --reload

# Testing with admin permissions
AB0T_AUTH_DEBUG=true \
AB0T_AUTH_BYPASS=true \
AB0T_AUTH_BYPASS_PERMISSIONS=admin:read,admin:write \
AB0T_AUTH_BYPASS_ROLES=admin \
pytest tests/

# CI pipeline
env:
  AB0T_AUTH_DEBUG: "true"
  AB0T_AUTH_BYPASS: "true"
  AB0T_AUTH_BYPASS_USER_ID: "ci_test_user"

Risk Assessment
---------------

Risk: Bypass enabled in production
Mitigation: Requires BOTH AB0T_AUTH_BYPASS=true AND AB0T_AUTH_DEBUG=true
Likelihood: Very Low (requires two misconfigurations)

Risk: Bypass not noticed during debugging
Mitigation: WARNING logged on every single request
Likelihood: Very Low (logs make it obvious)

Risk: Code paths differ between bypass and real auth
Mitigation: Inject real AuthenticatedUser object
Likelihood: None (same code paths used)

Recommendation
--------------
Proceed with implementation. The defense-in-depth approach provides
sufficient safety for production while enabling convenient local development
and testing workflows.
